"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const file_utils_1 = require("../core/file-utils");
const child_process_1 = require("child_process");
const hasha = require('hasha');
class Hasher {
    constructor(projectGraph, nxJson, options) {
        this.projectGraph = projectGraph;
        this.nxJson = nxJson;
        this.options = options;
        this.fileHashes = new FileHashes();
        this.projectHashes = new ProjectHashes(this.projectGraph, this.fileHashes);
    }
    hash(task) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [
                task.target.project || '',
                task.target.target || '',
                task.target.configuration || '',
                JSON.stringify(task.overrides)
            ];
            const values = yield Promise.all([
                this.projectHashes.hashProject(task.target.project, [
                    task.target.project
                ]),
                this.implicitDepsHash(),
                this.runtimeInputsHash()
            ]);
            return hasha([Hasher.version, ...args, ...values], { algorithm: 'sha256' });
        });
    }
    runtimeInputsHash() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runtimeInputs)
                return this.runtimeInputs;
            const inputs = this.options && this.options.runtimeCacheInputs
                ? this.options.runtimeCacheInputs
                : [];
            if (inputs.length > 0) {
                try {
                    const values = yield Promise.all(inputs.map((i) => __awaiter(this, void 0, void 0, function* () {
                        return child_process_1.execSync(i)
                            .toString()
                            .trim();
                    })));
                    this.runtimeInputs = hasha(values, { algorithm: 'sha256' });
                }
                catch (e) {
                    throw new Error(`Nx failed to execute runtimeCacheInputs defined in nx.json failed:\n${e.message}`);
                }
            }
            else {
                this.runtimeInputs = Promise.resolve('');
            }
            return this.runtimeInputs;
        });
    }
    implicitDepsHash() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.implicitDependencies)
                return this.implicitDependencies;
            const values = yield Promise.all([
                ...Object.keys(this.nxJson.implicitDependencies || {}).map(r => this.fileHashes.hashFile(r)),
                ...file_utils_1.rootWorkspaceFileNames().map(r => this.fileHashes.hashFile(r)),
                this.fileHashes.hashFile('package-lock.json'),
                this.fileHashes.hashFile('yarn.lock')
            ]);
            this.implicitDependencies = hasha(values, { algorithm: 'sha256' });
            return this.implicitDependencies;
        });
    }
}
exports.Hasher = Hasher;
Hasher.version = '1.0';
class ProjectHashes {
    constructor(projectGraph, fileHashes) {
        this.projectGraph = projectGraph;
        this.fileHashes = fileHashes;
        this.sourceHashes = {};
    }
    hashProject(projectName, visited) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve().then(() => __awaiter(this, void 0, void 0, function* () {
                const deps = (this.projectGraph.dependencies[projectName] || []).map(t => {
                    if (visited.indexOf(t.target) > -1) {
                        return '';
                    }
                    else {
                        visited.push(t.target);
                        return this.hashProject(t.target, visited);
                    }
                });
                const sources = this.hashProjectNodeSource(projectName);
                return hasha(yield Promise.all([...deps, sources]));
            }));
        });
    }
    hashProjectNodeSource(projectName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sourceHashes[projectName]) {
                this.sourceHashes[projectName] = new Promise((res) => __awaiter(this, void 0, void 0, function* () {
                    const p = this.projectGraph.nodes[projectName];
                    const values = yield Promise.all(p.data.files.map(f => this.fileHashes.hashFile(f.file)));
                    res(hasha(values, { algorithm: 'sha256' }));
                }));
            }
            return this.sourceHashes[projectName];
        });
    }
}
exports.ProjectHashes = ProjectHashes;
class FileHashes {
    constructor() {
        this.queue = [];
        this.numberOfConcurrentReads = 0;
        this.fileHashes = {};
        this.resolvers = {};
    }
    hashFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.fileHashes[path]) {
                this.fileHashes[path] = new Promise(res => {
                    this.resolvers[path] = res;
                    this.pushFileIntoQueue(path);
                });
            }
            return this.fileHashes[path];
        });
    }
    pushFileIntoQueue(path) {
        this.queue.push(path);
        if (this.numberOfConcurrentReads < 2000) {
            this.numberOfConcurrentReads++;
            this.takeFromQueue();
        }
    }
    takeFromQueue() {
        if (this.queue.length > 0) {
            const path = this.queue.pop();
            this.processPath(path)
                .then(value => {
                this.resolvers[path](value);
            })
                .then(() => this.takeFromQueue());
        }
        else {
            this.numberOfConcurrentReads--;
        }
    }
    processPath(path) {
        try {
            const stats = fs_1.statSync(path);
            const fileSizeInMegabytes = stats.size / 1000000;
            // large binary file, skip it
            if (fileSizeInMegabytes > 5) {
                return Promise.resolve(stats.size.toString());
            }
            else {
                return hasha.fromFile(path, { algorithm: 'sha256' });
            }
        }
        catch (e) {
            return Promise.resolve('');
        }
    }
}
exports.FileHashes = FileHashes;
