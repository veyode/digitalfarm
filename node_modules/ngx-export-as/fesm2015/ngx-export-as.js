import { Injectable, NgModule } from '@angular/core';
import { Observable } from 'rxjs';
import html2canvas from 'html2canvas';
import { utils, write } from 'xlsx';
import html2pdf from 'html2pdf.js';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
window['html2canvas'] = html2canvas;
class ExportAsService {
    constructor() { }
    /**
     * Main base64 get method, it will return the file as base64 string
     * @param {?} config your config
     * @return {?}
     */
    get(config) {
        // structure method name dynamically by type
        /** @type {?} */
        const func = 'get' + config.type.toUpperCase();
        // if type supported execute and return
        if (this[func]) {
            return this[func](config);
        }
        // throw error for unsupported formats
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => { observer.error('Export type is not supported.'); }));
    }
    /**
     * Save exported file in old javascript way
     * @param {?} config your custom config
     * @param {?} fileName Name of the file to be saved as
     * @return {?}
     */
    save(config, fileName) {
        // set download
        config.download = true;
        // get file name with type
        config.fileName = fileName + '.' + config.type;
        return this.get(config);
    }
    /**
     * Converts content string to blob object
     * @param {?} content string to be converted
     * @return {?}
     */
    contentToBlob(content) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            // get content string and extract mime type
            /** @type {?} */
            const arr = content.split(',');
            /** @type {?} */
            const mime = arr[0].match(/:(.*?);/)[1];
            /** @type {?} */
            const bstr = atob(arr[1]);
            /** @type {?} */
            let n = bstr.length;
            /** @type {?} */
            const u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            observer.next(new Blob([u8arr], { type: mime }));
            observer.complete();
        }));
    }
    /**
     * Removes base64 file type from a string like "data:text/csv;base64,"
     * @param {?} fileContent the base64 string to remove the type from
     * @return {?}
     */
    removeFileTypeFromBase64(fileContent) {
        /** @type {?} */
        const re = /^data:[^]*;base64,/g;
        /** @type {?} */
        const newContent = re[Symbol.replace](fileContent, '');
        return newContent;
    }
    /**
     * Structure the base64 file content with the file type string
     * @param {?} fileContent file content
     * @param {?} fileMime file mime type "text/csv"
     * @return {?}
     */
    addFileTypeToBase64(fileContent, fileMime) {
        return `data:${fileMime};base64,${fileContent}`;
    }
    /**
     * create downloadable file from dataURL
     * @param {?} fileName downloadable file name
     * @param {?} dataURL file content as dataURL
     * @return {?}
     */
    downloadFromDataURL(fileName, dataURL) {
        // create blob
        this.contentToBlob(dataURL).subscribe((/**
         * @param {?} blob
         * @return {?}
         */
        blob => {
            // download the blob
            this.downloadFromBlob(blob, fileName);
        }));
    }
    /**
     * Downloads the blob object as a file
     * @param {?} blob file object as blob
     * @param {?} fileName downloadable file name
     * @return {?}
     */
    downloadFromBlob(blob, fileName) {
        // get object url
        /** @type {?} */
        const url = window.URL.createObjectURL(blob);
        // check for microsoft internet explorer
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            // use IE download or open if the user using IE
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        }
        else {
            // if not using IE then create link element
            /** @type {?} */
            const element = document.createElement('a');
            // set download attr with file name
            element.setAttribute('download', fileName);
            // set the element as hidden
            element.style.display = 'none';
            // append the body
            document.body.appendChild(element);
            // set href attr
            element.href = url;
            // click on it to start downloading
            element.click();
            // remove the link from the dom
            document.body.removeChild(element);
        }
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getPDF(config) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            if (!config.options) {
                config.options = {};
            }
            config.options.filename = config.fileName;
            /** @type {?} */
            const element = document.getElementById(config.elementId);
            /** @type {?} */
            const pdf = html2pdf().set(config.options).from(element, 'element');
            /** @type {?} */
            const download = config.download;
            /** @type {?} */
            const pdfCallbackFn = config.options.pdfCallbackFn;
            if (download) {
                if (pdfCallbackFn) {
                    this.applyPdfCallbackFn(pdf, pdfCallbackFn).save();
                }
                else {
                    pdf.save();
                }
                observer.next();
                observer.complete();
            }
            else {
                if (pdfCallbackFn) {
                    this.applyPdfCallbackFn(pdf, pdfCallbackFn).outputPdf('datauristring').then((/**
                     * @param {?} data
                     * @return {?}
                     */
                    data => {
                        observer.next(data);
                        observer.complete();
                    }));
                }
                else {
                    pdf.outputPdf('datauristring').then((/**
                     * @param {?} data
                     * @return {?}
                     */
                    data => {
                        observer.next(data);
                        observer.complete();
                    }));
                }
            }
        }));
    }
    /**
     * @private
     * @param {?} pdf
     * @param {?} pdfCallbackFn
     * @return {?}
     */
    applyPdfCallbackFn(pdf, pdfCallbackFn) {
        return pdf.toPdf().get('pdf').then((/**
         * @param {?} pdfRef
         * @return {?}
         */
        (pdfRef) => {
            pdfCallbackFn(pdfRef);
        }));
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getPNG(config) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            const element = document.getElementById(config.elementId);
            html2canvas(element, config.options).then((/**
             * @param {?} canvas
             * @return {?}
             */
            (canvas) => {
                /** @type {?} */
                const imgData = canvas.toDataURL('image/PNG');
                if (config.type === 'png' && config.download) {
                    this.downloadFromDataURL(config.fileName, imgData);
                    observer.next();
                }
                else {
                    observer.next(imgData);
                }
                observer.complete();
            }), (/**
             * @param {?} err
             * @return {?}
             */
            err => {
                observer.error(err);
            }));
        }));
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getCSV(config) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            const element = document.getElementById(config.elementId);
            /** @type {?} */
            const csv = [];
            /** @type {?} */
            const rows = element.querySelectorAll('table tr');
            for (let index = 0; index < rows.length; index++) {
                /** @type {?} */
                const rowElement = rows[index];
                /** @type {?} */
                const row = [];
                /** @type {?} */
                const cols = rowElement.querySelectorAll('td, th');
                for (let colIndex = 0; colIndex < cols.length; colIndex++) {
                    /** @type {?} */
                    const col = cols[colIndex];
                    row.push(col.innerText);
                }
                csv.push(row.join(','));
            }
            /** @type {?} */
            const csvContent = 'data:text/csv;base64,' + this.btoa(csv.join('\n'));
            if (config.download) {
                this.downloadFromDataURL(config.fileName, csvContent);
                observer.next();
            }
            else {
                observer.next(csvContent);
            }
            observer.complete();
        }));
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getTXT(config) {
        /** @type {?} */
        const nameFrags = config.fileName.split('.');
        config.fileName = `${nameFrags[0]}.txt`;
        return this.getCSV(config);
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getXLS(config) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            const element = document.getElementById(config.elementId);
            /** @type {?} */
            const ws3 = utils.table_to_sheet(element, config.options);
            /** @type {?} */
            const wb = utils.book_new();
            utils.book_append_sheet(wb, ws3, config.fileName);
            /** @type {?} */
            const out = write(wb, { type: 'base64' });
            /** @type {?} */
            const xlsContent = 'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + out;
            if (config.download) {
                this.downloadFromDataURL(config.fileName, xlsContent);
                observer.next();
            }
            else {
                observer.next(xlsContent);
            }
            observer.complete();
        }));
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getXLSX(config) {
        return this.getXLS(config);
    }
    // private getDOCX(config: ExportAsConfig): Observable<string | null> {
    //   return Observable.create((observer) => {
    //     const contentDocument: string = document.getElementById(config.elementId).outerHTML;
    //     const content = '<!DOCTYPE html>' + contentDocument;
    //     const converted = htmlDocx.asBlob(content, config.options);
    //     if (config.download) {
    //       this.downloadFromBlob(converted, config.fileName);
    //       observer.next();
    //       observer.complete();
    //     } else {
    //       const reader = new FileReader();
    //       reader.onloadend = () => {
    //         const base64data = reader.result;
    //         observer.next(base64data);
    //         observer.complete();
    //       };
    //       reader.readAsDataURL(converted);
    //     }
    //   });
    // }
    // private getDOC(config: ExportAsConfig): Observable<string | null> {
    //   return this.getDOCX(config);
    // }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getJSON(config) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            const data = [];
            // first row needs to be headers
            /** @type {?} */
            const headers = [];
            /** @type {?} */
            const table = (/** @type {?} */ (document.getElementById(config.elementId)));
            for (let index = 0; index < table.rows[0].cells.length; index++) {
                headers[index] = table.rows[0].cells[index].innerHTML.toLowerCase().replace(/ /gi, '');
            }
            // go through cells
            for (let i = 1; i < table.rows.length; i++) {
                /** @type {?} */
                const tableRow = table.rows[i];
                /** @type {?} */
                const rowData = {};
                for (let j = 0; j < tableRow.cells.length; j++) {
                    rowData[headers[j]] = tableRow.cells[j].innerHTML;
                }
                data.push(rowData);
            }
            /** @type {?} */
            const jsonString = JSON.stringify(data);
            /** @type {?} */
            const jsonBase64 = this.btoa(jsonString);
            /** @type {?} */
            const dataStr = 'data:text/json;base64,' + jsonBase64;
            if (config.download) {
                this.downloadFromDataURL(config.fileName, dataStr);
                observer.next();
            }
            else {
                observer.next(data);
            }
            observer.complete();
        }));
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    getXML(config) {
        return Observable.create((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            let xml = '<?xml version="1.0" encoding="UTF-8"?><Root><Classes>';
            /** @type {?} */
            const tritem = document.getElementById(config.elementId).getElementsByTagName('tr');
            for (let i = 0; i < tritem.length; i++) {
                /** @type {?} */
                const celldata = tritem[i];
                if (celldata.cells.length > 0) {
                    xml += '<Class name="' + celldata.cells[0].textContent + '">\n';
                    for (let m = 1; m < celldata.cells.length; ++m) {
                        xml += '\t<data>' + celldata.cells[m].textContent + '</data>\n';
                    }
                    xml += '</Class>\n';
                }
            }
            xml += '</Classes></Root>';
            /** @type {?} */
            const base64 = 'data:text/xml;base64,' + this.btoa(xml);
            if (config.download) {
                this.downloadFromDataURL(config.fileName, base64);
                observer.next();
            }
            else {
                observer.next(base64);
            }
            observer.complete();
        }));
    }
    /**
     * @private
     * @param {?} content
     * @return {?}
     */
    btoa(content) {
        return btoa(unescape(encodeURIComponent(content)));
    }
}
ExportAsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExportAsService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ExportAsModule {
}
ExportAsModule.decorators = [
    { type: NgModule, args: [{
                providers: [ExportAsService],
            },] }
];

export { ExportAsModule, ExportAsService };
//# sourceMappingURL=ngx-export-as.js.map
